# 1 javaの基本

1. パッケージ宣言に関するルール
   1.1 必ずソースコードの先頭行に記述する
   1.2 前に記述できるのはコメントだけである
   1.3 パッケージ名.クラス名　→　完全修飾クラス名　→　名前区間を提供し、名前の衝突を避ける
   1.4 パッケージ単位でアクセス制御する
   例　package aa
      class test{//any code}
   → 外部パッケージからアクセスできない
   1.5 パッケージはディレクトリ構造とマッピング
   1.6 クラスは必ずパッケージに所属する　ディフォルトはdefault 無名パッケージ
   1.7 無名パッケージに属するクラスは同じ無名パッケージに属するクラスからしかあくせすできない

2. インポート
   2.1 import static ○  static import ☓　　　
   2.2 メソッドのstatic インポート宣言では、メソッド名にかっこ「()」や引数を付けない。
   2.3 インポートしたクラスに、インポートされたメソッドやフィールドと同名のものがあった場合,そのインポートは無視される
   2.4 java コマンドでのクラス実行時に指定する起動パラメータはString配列型オブジェクトに格納されるため、1番目が配列型変数args[0]、2番目がargs[1]となる

3. java コマンドの構文


   3.1 java 完全修飾クラス名　引数1　引数2
   3.2 引数1,引数2は起動パラメータやコマンドライン引数と呼ぶ

# 2 javaのデータ型の操作

1. javaでは数値を10進数のほかに、2進数、8進数、16進数のリテラルで表示でき、それぞれ、0b,0,0xで始め

2. リテラルの先頭と末尾には記述できない

   2.1　記号の前後には記述できない

   2.2　利用できる記号は、小数点を表すドット「.」long型やfloat型リテラルを表す[L]や[F]、2進数を表す[0b] 16進数を表す[0x]

3. char型の変数には、ダブルクォーテーション「"]で括った文字列りてらるは代入できません。

   代入できるのは、シングルクォーテーション[']で括った文字列リテラル、もしくは数値のみ、

   シングルクォーテーション、ダブルクォーテーションを間違えないように

   char型の変数に代入できるのは、0~65535までの数値だけ、符号つきの整数(負の値)は扱えない

   Unicodeの代入￥u30A2

4. 識別子に使える記号はアンダースコア「_」とドル[$]

5. 以下の識別子が使えない　!@#%&^()':;[/\\]

6. ガーベジコレクション、ガーベジコレクション

7. インスタンスの参照がなくなった時点で、カーベッジコレクションの対象となる

8. カーベッジコレクションのタイミングはjvmが決めます。gcメソッドは促すだけで保証はされない

# 3 演算子っと判定構造の使用

​    1.byteとshortは扱う範囲が狭いデータ型

　2.byteとbooleanの互換性はない

　3.インクリメント演算子「++」やデクリメント「--」演算子の前置と後置の違いによる演算子の動作順序は　重要ポイント

　4.カッコやインクリメント、デクリメントが最優先である

　4.1数学と同じで乗算や除算、剰余算が加算や減算より優先される

​    5 ネストした三項演算子は「？」と「：」が交互に現れ、最後だけ「：」で終わります

　6 switch文のcase値として使用できる値　

　　6.1　条件式に戻り値と同じ型か互換性がある型であること

　　6.2    定数であるか、コンパイル時に値を決めることができること

　　6.3    nullでないこと　

　7 switch 文の条件式　

　　7.1 int型以下の整数型　と　そのラッパークラス

　　7.2 文字と文字列　

　　7.3 列挙型　eum 

　　　　

# 4 配列の作成と使用

1. new int[0] でもコンパイルエラーにならない

2. 配列宣言

   2.1　int[] a  int a[]

   2.2    int[]  a[]   int [] [] a  int a[] []

   2.3    int[] array[] []  int[] [] array[]

3. 要素の指定のとき、データ型変換は行わない、宣言したデータ型しか使えない

4. 2次元配列宣言　1次元の配列の要素数を先に記述しなければならない。

5. 配列インスタンス生成・初期化のとき

   5.1　int[] a = {2,3}  int[] a = new int[]{2,3}  int[] a = {} →　ok  

   int[] a = new int[2]{2,3} →　エラーになる　　int[] a ; a={2,3} →　エラーになる

   5.2   new と初期化演算子の両方を使って配列のインスタンス生成と初期化を同時に行う場合、要素数は自動算出されるため、大カッコ中に要素数は指定できない

   5.3　初期化演算子を使って、配列のインスタンス生成と初期化を同時に行う場合、変数の宣言と参照の代入も同時に行う。セミコロン「；」を使って変数宣言と配列のインスタンス生成のタイミングを分けることはできない

   

6. ```java
   public class Test {
   
       public static void main(String[] args){
           String[][] array = {{"A","B"},null,{"C","D","E"}};
           int total = 0;
           for(String[] tmp:array){
               total += tmp.length;
           }
       }
   }
   ```

```java
// public interface A{}

// public abstract class B implements A{}

// public class c extends B{}

// public class d extends C{}



public class Test {

    public static void main(String[] args){
          A{}  array = {newC(),null,new D()};
          Object [] objArray = array;
    }
}
```

# 5 ループ構造と使用

# 6 メソッドとカプセル化び操作

# 7 継承の操作

# 8 例外の処理

# 9 java APIの主要なクラス操作